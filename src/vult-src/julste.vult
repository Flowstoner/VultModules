/*
This model is based on the code by Julian Parker and Stefano Dâ€™Angelo on their paper
"A DIGITAL MODEL OF THE BUCHLA LOWPASS-GATE" I just transcribed the model to Vult code.

Copyright (c) 2017 Leonardo Laguna Ruiz (modlfo@gmail.com), All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1.- Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2.- Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3.- Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
4.- Commercial use requires explicit permission of the author.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/


// Vactrol time-domain behaviour filter

external powf(x:real, y:real) : real "powf";

fun vactrol(in1) {
   // Vactrol time-domain behaviour filter
   mem s1;
   val a_base = 1000.0 * pi() / Util.getSampleRate();
   val t_down = 3e3; // Fall time
   t_down = 10.0 + t_down * (1.0 - 0.9 * s1);
   val a_down = a_base / t_down;
   val t_up = 20.0; // Rise time
   t_up = 1.0 + t_up * (1.0 - 0.999 * s1);
   val a_up = a_base / t_up;

   val ds1 = in1 - s1;

   val x = (in1 - s1) * a_up / (1.0 + a_up);
   if (ds1 <= 0.0) {
      x = (in1 - s1) * a_down / (1.0 + a_down);
   }

   val y = x + s1;
   s1 = clip(y + x, -1.0, 1.0);
   return y;
}

fun control(in1, in2, in3) {
   //Nonlinear control circuit maps V_b to R_f (Vactrol Resistance)

   // Inputs
   val Vb = clip(in1, -10.0, 50.0);
   val offset = 0.9999 * in2 + 0.0001;
   val scale = clip(in3, 0.0, 1.0);
   scale = 0.48; // This value is tuned for appropriate input range.

   // Constants
   val A = 3.4645912;
   val B = 1136.2129956;
   val Ifmin = 10.1e-6;
   val Ifmax = 40e-3;
   val R2max = 10e3;
   val R6max = 20e3;
   val R7 = 33e3;
   val R3 = 150e3;
   val R5 = 100e3;
   val R4 = 470e3;
   val R8 = 4.7e3;
   val R9 = 470.0;
   val VB = 3.9;
   val VF = 0.7;
   val VT = 26e-3;
   val n = 3.9696;
   val kl = 6.3862;
   val G = 2e5;
   val Vs = 15.0;
   val k0 = 1.468e2;
   val k1 = 4.9202e-1;
   val k2 = 4.1667e-4;
   val k3 = 7.3915e-9;
   val gamma = 0.0001;

   val R6 = scale * R6max;
   val R1 = (1.0 - offset) * R2max;
   val R2 = offset * R2max;

   val alpha = 1.0 + (R6 + R7) * (1.0 / R3 + 1.0 / R5);
   val beta = ((1.0 / alpha) - 1.0) / (R6 + R7) - 1.0 / R8;

   val bound1 = 600.0 * alpha * n * VT / (G * (R6 + R7 - 1.0 / (alpha * beta)));

   val Ia = Vb / R5 + Vs / (R3 * (1.0 + R1 / R2));

   val V3 = 0.;
   val If = 0.;
   val flag = 0.;
   if (Ia <= -bound1)
   {
      V3 = -Ia / (alpha * beta);
   }
   else if (Ia < bound1)
   {
      val x = G * Ia * (R6 + R7 - 1.0 / (alpha * beta)) / (alpha * n * VT);
      val w = k0 + k1 * x + k2 * x * x + k3 * x * x * x;
      V3 = -(alpha / G) * n * VT * w - Ia / (alpha * beta);
   }
   else {
      V3 = kl * alpha / G * n * VT - Ia * (R6 + R7);
   }

   val Ifbound1 = alpha * (Ifmin - beta * V3);
   val Ifbound2 = VB / (R6 + R7);
   val Ifbound3 = (gamma * G * VB + alpha * R9 * (VB * beta + Ifmax))/(gamma * G * (R6 + R7) + R9);

   if (Ia <= Ifbound1)
      If = Ifmin;
   else if (Ia <= Ifbound2)
      If = beta * V3 + Ia / alpha;
   else if (Ia <= Ifbound3)
      If = gamma * G * (Ia * (R6 + R7) - VB) / (alpha * R9) - beta * VB + Ia / alpha;
   else
      If = Ifmax;

   val Rf = B + A / powf(If, 1.4);
   return Rf;
}

fun filter(in1:real, in2:real, in3:real, in4:real, in5, in6){
   mem so, sx, sd, xo;
   val c1 = 1e-09;
   val c2 = 2.2e-10;
   val c3 = 4.7e-09;

   if (in5 < 0.5) c3 = 0.0;

   //r1 = 1e3;
   val rf = in2;
   //rf = 30e3;
   val r3 = (1.0 - in3) * 5e6 + 10e3;

   val max_res = 1.0 * (2.0 * c1 * r3 + (c2 + c3) * (r3 + rf)) / (c3 * r3);
   val a = clip(in4, 0.0, max_res);
   //a = in4* max_res;
   val x = in1;

   val f = 0.5 / Util.getSampleRate();
   //f = 2*pi * (in2+1e-3)*0.5/samplerate;

   val a1 = 1.0 / (c1 * rf);
   val a2 = -(1.0 / rf + 1.0 / r3) / c1;
   val b1 = 1.0 / (rf * c2);
   val b2 = -2.0 / (rf * c2);
   val b3 = 1.0 / (rf * c2);
   val b4 = c3 / c2;
   val d1 = a;
   val d2 = -1.0;
   val tanh_xo = Util.saturate(xo);
   //b2 = (a*c3/c1 -1 - 1/(1+r1/rf))/(rf*(c2+c3));			//	Extra Feedback resistor
   //b3 =(1/(1+r1/rf)- (1+rf/r3)*a*c3/c1)/(rf*(c2+c3));	//	Extra Feedback resistor

   val Dx = 1.0 / (1.0 - b2 * f);
   val Do = 1.0 / (1.0 - a2 * f);

   val tanh_xo_2 = tanh_xo * tanh_xo;

   val out1, out2, out3;
   if (in6 > 0.5) {
      val Dmas = 1.0 / (1.0 - Dx * (f * f * b3 * Do * a1 + b4 * f * d1 * (1.0 - tanh_xo_2) * Do * a1 + b4 * d2));

      val yx =(sx + f * b1 * x + f * b3 * Do * so + f * b4 * (sd + (1.0 / f) * d1 * (tanh_xo - xo * (1.0 - tanh_xo_2))) + b4 * d1 * (1.0 - tanh_xo_2) * Do * so) * Dx * Dmas;

      val yo = (so + f * a1 * yx) * Do;

      val yd = (sd + (1.0 / f) * d1 * (tanh_xo - xo * (1.0 - tanh_xo_2))) + (1.0 / f) * (d1 * ((1.0 - tanh_xo_2)) * yo + d2 * yx);

      sx = sx + 2.0 * f * (b1 * x + b2 * yx + b3 * yo + b4 * yd);

      so = so + 2.0 * f * (a1 * yx + a2 * yo);

      sd = -(sd + (2.0 / f) * d1 * (tanh_xo - xo * (1.0 - tanh_xo_2))) - (2.0 / f) * (d1 * (1.0 - tanh_xo_2) * yo + d2 * yx);
      xo = yo;
      out1 = yo;
      out2 = yx;
      out3 = yd;
   }
   else {
      val Dmas = 1.0 / (1.0 - Dx * (f * f * b3 * Do * a1 + b4 * f * d1 * Do * a1 + b4 * d2));

      val yx =(sx + f * b1 * x + f * b3 * Do * so + f * b4 * sd + b4 * d1 * Do * so) * Dx * Dmas;

      val yo =(so + f * a1 * yx) * Do;

      val yd = sd + (1.0 / f) * (d1 * yo + d2 * yx);

      sx = sx + 2.0 * f * (b1 * x + b2 * yx + b3 * yo + b4 * yd);

      so = so + 2.0 * f * (a1 * yx + a2 * yo);

      sd = -sd - (2.0 / f) * (d1 * yo + d2 * yx);

      out1 = yo;
      out2 = yx;
      out3 = yd;
   }
   return out1, out2, out3;
}

fun julste(gate, audio, offset, res, vcaness, lp_mode, nonlin_mode) {
   val x = 10.0 * vactrol(gate);
   val ctrl = control(x, clip(offset, 0.0, 1.0), 0.0);
   val vca =Util.polylog(Util.polylog(clip(vcaness, 0.0, 1.0)));
   val out1, _, _ = filter(audio, ctrl, vca, clip(res, 0.0, 1.0) * 2.0, lp_mode, nonlin_mode);
   return out1;
}

